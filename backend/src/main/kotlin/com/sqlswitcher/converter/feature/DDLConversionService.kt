package com.sqlswitcher.converter.feature

import com.sqlswitcher.converter.DialectType
import com.sqlswitcher.converter.ConversionWarning
import com.sqlswitcher.converter.feature.ddl.IndexConversionService
import com.sqlswitcher.converter.mapping.DataTypeMappingRegistry
import net.sf.jsqlparser.statement.create.table.CreateTable
import net.sf.jsqlparser.statement.create.table.ColumnDefinition
import org.springframework.stereotype.Service

/**
 * DDL (CREATE TABLE, DROP TABLE 등) 변환 서비스
 *
 * 인덱스 관련 변환은 IndexConversionService에서 처리합니다.
 * - ddl/IndexConversionService.kt: CREATE INDEX 변환 로직
 */
@Service
class DDLConversionService(
    private val dataTypeService: DataTypeConversionService,
    private val dataTypeMappingRegistry: DataTypeMappingRegistry,
    private val indexConversionService: IndexConversionService
) {

    companion object {
        private val AUTO_INCREMENT_CHECK_PATTERN = Regex("AUTO_INCREMENT", RegexOption.IGNORE_CASE)
        private val AUTO_INCREMENT_REPLACE_PATTERN = Regex("""\bAUTO_INCREMENT\b""", RegexOption.IGNORE_CASE)
        private val CASCADE_CONSTRAINTS_PATTERN = Regex("""CASCADE\s+CONSTRAINTS""", RegexOption.IGNORE_CASE)
        private val PURGE_PATTERN = Regex("""\s+PURGE\b""", RegexOption.IGNORE_CASE)
    }

    /**
     * CREATE TABLE 문 변환
     */
    fun convertCreateTable(
        createTable: CreateTable,
        sourceDialect: DialectType,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        val tableName = convertTableName(createTable.table.name, targetDialect)
        val columns = createTable.columnDefinitions?.map { col ->
            convertColumnDefinition(col, sourceDialect, targetDialect, warnings, appliedRules)
        } ?: emptyList()

        val sb = StringBuilder()
        sb.append("CREATE TABLE $tableName (\n")
        sb.append(columns.joinToString(",\n") { "    $it" })
        sb.append("\n)")

        return sb.toString()
    }

    /**
     * 컬럼 정의 변환
     */
    private fun convertColumnDefinition(
        column: ColumnDefinition,
        sourceDialect: DialectType,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        val columnName = convertColumnName(column.columnName, targetDialect)
        val dataType = dataTypeService.convertDataType(
            column.colDataType.toString(),
            sourceDialect,
            targetDialect,
            warnings,
            appliedRules
        )

        val specs = column.columnSpecs?.joinToString(" ") ?: ""
        val convertedSpecs = convertColumnSpecs(specs, sourceDialect, targetDialect, appliedRules)

        return if (convertedSpecs.isNotEmpty()) {
            "$columnName $dataType $convertedSpecs"
        } else {
            "$columnName $dataType"
        }
    }

    /**
     * 컬럼 스펙 변환 (DEFAULT, NOT NULL 등)
     */
    private fun convertColumnSpecs(
        specs: String,
        sourceDialect: DialectType,
        targetDialect: DialectType,
        appliedRules: MutableList<String>
    ): String {
        var result = specs

        // AUTO_INCREMENT 변환
        if (sourceDialect == DialectType.MYSQL && AUTO_INCREMENT_CHECK_PATTERN.containsMatchIn(specs)) {
            when (targetDialect) {
                DialectType.ORACLE, DialectType.POSTGRESQL -> {
                    result = AUTO_INCREMENT_REPLACE_PATTERN.replace(result, "GENERATED BY DEFAULT AS IDENTITY")
                    appliedRules.add("AUTO_INCREMENT → GENERATED BY DEFAULT AS IDENTITY")
                }
                else -> {}
            }
        }

        return result
    }

    /**
     * CREATE INDEX 변환 (IndexConversionService로 위임)
     */
    fun convertCreateIndex(
        sql: String,
        sourceDialect: DialectType,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        return indexConversionService.convertCreateIndex(
            sql, sourceDialect, targetDialect, warnings, appliedRules
        )
    }

    /**
     * DROP TABLE 변환
     */
    fun convertDropTable(
        sql: String,
        sourceDialect: DialectType,
        targetDialect: DialectType,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        // CASCADE CONSTRAINTS (Oracle) → CASCADE (PostgreSQL)
        if (sourceDialect == DialectType.ORACLE && targetDialect == DialectType.POSTGRESQL) {
            result = CASCADE_CONSTRAINTS_PATTERN.replace(result, "CASCADE")
            appliedRules.add("CASCADE CONSTRAINTS → CASCADE")
        }

        // PURGE 제거 (Oracle 전용)
        if (targetDialect != DialectType.ORACLE) {
            result = PURGE_PATTERN.replace(result, "")
        }

        appliedRules.add("DROP TABLE 변환")
        return result
    }

    private fun convertTableName(name: String, targetDialect: DialectType): String {
        val cleaned = name.trim('"', '`', '[', ']')
        return when (targetDialect) {
            DialectType.MYSQL -> "`$cleaned`"
            else -> "\"$cleaned\""
        }
    }

    private fun convertColumnName(name: String, targetDialect: DialectType): String {
        val cleaned = name.trim('"', '`', '[', ']')
        return when (targetDialect) {
            DialectType.MYSQL -> "`$cleaned`"
            else -> "\"$cleaned\""
        }
    }
}