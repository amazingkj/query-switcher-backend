package com.sqlswitcher.converter.feature

import com.sqlswitcher.converter.DialectType
import com.sqlswitcher.converter.ConversionWarning
import com.sqlswitcher.converter.WarningType
import com.sqlswitcher.converter.WarningSeverity
import com.sqlswitcher.converter.mapping.DataTypeMappingRegistry
import net.sf.jsqlparser.statement.create.table.CreateTable
import net.sf.jsqlparser.statement.create.table.ColumnDefinition
import org.springframework.stereotype.Service

/**
 * DDL (CREATE TABLE, CREATE INDEX 등) 변환 서비스
 */
@Service
class DDLConversionService(
    private val dataTypeService: DataTypeConversionService,
    private val dataTypeMappingRegistry: DataTypeMappingRegistry
) {

    /**
     * CREATE TABLE 문 변환
     */
    fun convertCreateTable(
        createTable: CreateTable,
        sourceDialect: DialectType,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        val tableName = convertTableName(createTable.table.name, targetDialect)
        val columns = createTable.columnDefinitions?.map { col ->
            convertColumnDefinition(col, sourceDialect, targetDialect, warnings, appliedRules)
        } ?: emptyList()

        val sb = StringBuilder()
        sb.append("CREATE TABLE $tableName (\n")
        sb.append(columns.joinToString(",\n") { "    $it" })
        sb.append("\n)")

        return sb.toString()
    }

    /**
     * 컬럼 정의 변환
     */
    private fun convertColumnDefinition(
        column: ColumnDefinition,
        sourceDialect: DialectType,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        val columnName = convertColumnName(column.columnName, targetDialect)
        val dataType = dataTypeService.convertDataType(
            column.colDataType.toString(),
            sourceDialect,
            targetDialect,
            warnings,
            appliedRules
        )

        val specs = column.columnSpecs?.joinToString(" ") ?: ""
        val convertedSpecs = convertColumnSpecs(specs, sourceDialect, targetDialect, appliedRules)

        return if (convertedSpecs.isNotEmpty()) {
            "$columnName $dataType $convertedSpecs"
        } else {
            "$columnName $dataType"
        }
    }

    /**
     * 컬럼 스펙 변환 (DEFAULT, NOT NULL 등)
     */
    private fun convertColumnSpecs(
        specs: String,
        sourceDialect: DialectType,
        targetDialect: DialectType,
        appliedRules: MutableList<String>
    ): String {
        var result = specs

        // AUTO_INCREMENT 변환
        if (sourceDialect == DialectType.MYSQL && specs.contains(Regex("AUTO_INCREMENT", RegexOption.IGNORE_CASE))) {
            when (targetDialect) {
                DialectType.ORACLE -> {
                    result = result.replace(
                        Regex("\\bAUTO_INCREMENT\\b", RegexOption.IGNORE_CASE),
                        "GENERATED BY DEFAULT AS IDENTITY"
                    )
                    appliedRules.add("AUTO_INCREMENT → GENERATED BY DEFAULT AS IDENTITY")
                }
                DialectType.POSTGRESQL -> {
                    result = result.replace(
                        Regex("\\bAUTO_INCREMENT\\b", RegexOption.IGNORE_CASE),
                        "GENERATED BY DEFAULT AS IDENTITY"
                    )
                    appliedRules.add("AUTO_INCREMENT → GENERATED BY DEFAULT AS IDENTITY")
                }
                else -> {}
            }
        }

        return result
    }

    /**
     * CREATE INDEX 변환
     */
    fun convertCreateIndex(
        sql: String,
        sourceDialect: DialectType,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        // 인용문자 변환
        val sourceQuote = if (sourceDialect == DialectType.MYSQL) "`" else "\""
        val targetQuote = if (targetDialect == DialectType.MYSQL) "`" else "\""
        result = result.replace(sourceQuote, targetQuote)

        // Oracle 전용 인덱스 옵션 처리
        if (sourceDialect == DialectType.ORACLE) {
            result = convertOracleIndexOptions(result, targetDialect, warnings, appliedRules)
        }

        // MySQL 전용 인덱스 옵션 처리
        if (sourceDialect == DialectType.MYSQL) {
            result = convertMySqlIndexOptions(result, targetDialect, warnings, appliedRules)
        }

        // PostgreSQL 전용 인덱스 옵션 처리
        if (sourceDialect == DialectType.POSTGRESQL) {
            result = convertPostgreSqlIndexOptions(result, targetDialect, warnings, appliedRules)
        }

        // 함수 기반 인덱스 변환
        result = convertFunctionBasedIndex(result, sourceDialect, targetDialect, warnings, appliedRules)

        appliedRules.add("CREATE INDEX 변환")
        return result
    }

    /**
     * Oracle 인덱스 옵션 변환
     */
    private fun convertOracleIndexOptions(
        sql: String,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        // TABLESPACE 절 처리
        val tablespacePattern = Regex("""TABLESPACE\s+\w+""", RegexOption.IGNORE_CASE)
        if (tablespacePattern.containsMatchIn(result)) {
            when (targetDialect) {
                DialectType.MYSQL -> {
                    result = tablespacePattern.replace(result, "")
                    warnings.add(ConversionWarning(
                        WarningType.SYNTAX_DIFFERENCE,
                        "MySQL은 TABLESPACE 절을 인덱스에서 지원하지 않습니다.",
                        WarningSeverity.INFO
                    ))
                }
                DialectType.POSTGRESQL -> {
                    // PostgreSQL은 TABLESPACE 지원
                    appliedRules.add("TABLESPACE 절 유지 (PostgreSQL)")
                }
                else -> {}
            }
        }

        // PCTFREE, INITRANS 등 Oracle 스토리지 옵션 제거
        val storagePattern = Regex("""(PCTFREE|INITRANS|MAXTRANS|STORAGE\s*\([^)]*\)|LOGGING|NOLOGGING|PARALLEL|NOPARALLEL)\s*\d*""", RegexOption.IGNORE_CASE)
        if (storagePattern.containsMatchIn(result)) {
            result = storagePattern.replace(result, "")
            appliedRules.add("Oracle 스토리지 옵션 제거")
        }

        // BITMAP 인덱스 처리
        if (result.uppercase().contains("BITMAP")) {
            when (targetDialect) {
                DialectType.MYSQL -> {
                    result = result.replace(Regex("\\bBITMAP\\b", RegexOption.IGNORE_CASE), "")
                    warnings.add(ConversionWarning(
                        WarningType.UNSUPPORTED_FUNCTION,
                        "MySQL은 BITMAP 인덱스를 지원하지 않습니다.",
                        WarningSeverity.WARNING,
                        "일반 B-tree 인덱스로 변환됩니다."
                    ))
                }
                DialectType.POSTGRESQL -> {
                    result = result.replace(Regex("\\bBITMAP\\b", RegexOption.IGNORE_CASE), "")
                    warnings.add(ConversionWarning(
                        WarningType.SYNTAX_DIFFERENCE,
                        "PostgreSQL은 BITMAP 인덱스 대신 GIN 인덱스를 고려하세요.",
                        WarningSeverity.INFO
                    ))
                }
                else -> {}
            }
        }

        // REVERSE 인덱스 처리
        if (result.uppercase().contains("REVERSE")) {
            result = result.replace(Regex("\\bREVERSE\\b", RegexOption.IGNORE_CASE), "")
            warnings.add(ConversionWarning(
                WarningType.UNSUPPORTED_FUNCTION,
                "REVERSE 인덱스는 ${targetDialect.name}에서 지원하지 않습니다.",
                WarningSeverity.WARNING
            ))
        }

        // LOCAL/GLOBAL 파티션 인덱스
        val partitionIndexPattern = Regex("""(LOCAL|GLOBAL)\s*(PARTITION)?""", RegexOption.IGNORE_CASE)
        if (partitionIndexPattern.containsMatchIn(result)) {
            result = partitionIndexPattern.replace(result, "")
            warnings.add(ConversionWarning(
                WarningType.MANUAL_REVIEW_NEEDED,
                "파티션 인덱스는 수동 변환이 필요합니다.",
                WarningSeverity.WARNING
            ))
        }

        return result.replace(Regex("\\s+"), " ").trim()
    }

    /**
     * MySQL 인덱스 옵션 변환
     */
    private fun convertMySqlIndexOptions(
        sql: String,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        // USING BTREE/HASH 처리
        val usingPattern = Regex("""USING\s+(BTREE|HASH)""", RegexOption.IGNORE_CASE)
        val usingMatch = usingPattern.find(result)
        if (usingMatch != null) {
            when (targetDialect) {
                DialectType.ORACLE -> {
                    result = usingPattern.replace(result, "")
                    appliedRules.add("USING 절 제거 (Oracle)")
                }
                DialectType.POSTGRESQL -> {
                    val method = usingMatch.groupValues[1].uppercase()
                    if (method == "HASH") {
                        // PostgreSQL은 USING hash 지원
                        appliedRules.add("USING HASH 유지 (PostgreSQL)")
                    }
                }
                else -> {}
            }
        }

        // FULLTEXT 인덱스 처리
        if (result.uppercase().contains("FULLTEXT")) {
            when (targetDialect) {
                DialectType.ORACLE -> {
                    warnings.add(ConversionWarning(
                        WarningType.SYNTAX_DIFFERENCE,
                        "Oracle에서는 Oracle Text를 사용하세요.",
                        WarningSeverity.WARNING,
                        "CREATE INDEX idx ON table(col) INDEXTYPE IS CTXSYS.CONTEXT"
                    ))
                    result = result.replace(Regex("\\bFULLTEXT\\b", RegexOption.IGNORE_CASE), "")
                }
                DialectType.POSTGRESQL -> {
                    warnings.add(ConversionWarning(
                        WarningType.SYNTAX_DIFFERENCE,
                        "PostgreSQL에서는 GIN 인덱스와 to_tsvector를 사용하세요.",
                        WarningSeverity.WARNING,
                        "CREATE INDEX idx ON table USING GIN(to_tsvector('english', col))"
                    ))
                    result = result.replace(Regex("\\bFULLTEXT\\b", RegexOption.IGNORE_CASE), "")
                }
                else -> {}
            }
        }

        // SPATIAL 인덱스 처리
        if (result.uppercase().contains("SPATIAL")) {
            when (targetDialect) {
                DialectType.POSTGRESQL -> {
                    result = result.replace(Regex("\\bSPATIAL\\b", RegexOption.IGNORE_CASE), "")
                    result = result.replace("CREATE INDEX", "CREATE INDEX")
                    warnings.add(ConversionWarning(
                        WarningType.SYNTAX_DIFFERENCE,
                        "PostgreSQL에서는 PostGIS와 GIST 인덱스를 사용하세요.",
                        WarningSeverity.WARNING,
                        "CREATE INDEX idx ON table USING GIST(geom_col)"
                    ))
                }
                else -> {
                    result = result.replace(Regex("\\bSPATIAL\\b", RegexOption.IGNORE_CASE), "")
                    warnings.add(ConversionWarning(
                        WarningType.UNSUPPORTED_FUNCTION,
                        "SPATIAL 인덱스는 ${targetDialect.name}에서 다른 방식으로 구현해야 합니다.",
                        WarningSeverity.WARNING
                    ))
                }
            }
        }

        return result.replace(Regex("\\s+"), " ").trim()
    }

    /**
     * PostgreSQL 인덱스 옵션 변환
     */
    private fun convertPostgreSqlIndexOptions(
        sql: String,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        // USING GIN/GIST/BRIN 처리
        val usingPattern = Regex("""USING\s+(GIN|GIST|BRIN|HASH|BTREE)""", RegexOption.IGNORE_CASE)
        val usingMatch = usingPattern.find(result)
        if (usingMatch != null) {
            val method = usingMatch.groupValues[1].uppercase()
            when (targetDialect) {
                DialectType.MYSQL -> {
                    when (method) {
                        "GIN", "GIST", "BRIN" -> {
                            result = usingPattern.replace(result, "")
                            warnings.add(ConversionWarning(
                                WarningType.UNSUPPORTED_FUNCTION,
                                "MySQL은 $method 인덱스를 지원하지 않습니다.",
                                WarningSeverity.WARNING,
                                "B-tree 인덱스로 대체됩니다."
                            ))
                        }
                        "HASH" -> {
                            appliedRules.add("USING HASH 유지 (MySQL)")
                        }
                    }
                }
                DialectType.ORACLE -> {
                    result = usingPattern.replace(result, "")
                    if (method in listOf("GIN", "GIST", "BRIN")) {
                        warnings.add(ConversionWarning(
                            WarningType.UNSUPPORTED_FUNCTION,
                            "Oracle은 $method 인덱스를 지원하지 않습니다.",
                            WarningSeverity.WARNING
                        ))
                    }
                }
                else -> {}
            }
        }

        // INCLUDE 절 처리 (PostgreSQL 11+)
        val includePattern = Regex("""INCLUDE\s*\([^)]+\)""", RegexOption.IGNORE_CASE)
        if (includePattern.containsMatchIn(result)) {
            when (targetDialect) {
                DialectType.MYSQL -> {
                    result = includePattern.replace(result, "")
                    warnings.add(ConversionWarning(
                        WarningType.UNSUPPORTED_FUNCTION,
                        "MySQL은 INCLUDE 절을 지원하지 않습니다.",
                        WarningSeverity.WARNING
                    ))
                }
                DialectType.ORACLE -> {
                    result = includePattern.replace(result, "")
                    warnings.add(ConversionWarning(
                        WarningType.UNSUPPORTED_FUNCTION,
                        "Oracle은 INCLUDE 절을 지원하지 않습니다.",
                        WarningSeverity.WARNING
                    ))
                }
                else -> {}
            }
        }

        // WHERE 절 (Partial Index) 처리
        val wherePattern = Regex("""WHERE\s+.+$""", setOf(RegexOption.IGNORE_CASE, RegexOption.MULTILINE))
        if (wherePattern.containsMatchIn(result)) {
            when (targetDialect) {
                DialectType.MYSQL -> {
                    result = wherePattern.replace(result, "")
                    warnings.add(ConversionWarning(
                        WarningType.UNSUPPORTED_FUNCTION,
                        "MySQL은 부분 인덱스(Partial Index)를 지원하지 않습니다.",
                        WarningSeverity.WARNING,
                        "전체 인덱스로 변환됩니다."
                    ))
                }
                DialectType.ORACLE -> {
                    warnings.add(ConversionWarning(
                        WarningType.SYNTAX_DIFFERENCE,
                        "Oracle에서는 함수 기반 인덱스로 부분 인덱스를 시뮬레이션할 수 있습니다.",
                        WarningSeverity.WARNING
                    ))
                }
                else -> {}
            }
        }

        return result.replace(Regex("\\s+"), " ").trim()
    }

    /**
     * 함수 기반 인덱스 변환
     */
    private fun convertFunctionBasedIndex(
        sql: String,
        sourceDialect: DialectType,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        // UPPER, LOWER 함수 기반 인덱스
        val upperPattern = Regex("""UPPER\s*\(\s*(\w+)\s*\)""", RegexOption.IGNORE_CASE)
        val lowerPattern = Regex("""LOWER\s*\(\s*(\w+)\s*\)""", RegexOption.IGNORE_CASE)

        when (targetDialect) {
            DialectType.MYSQL -> {
                // MySQL 5.7 미만에서는 함수 기반 인덱스 미지원
                if (upperPattern.containsMatchIn(result) || lowerPattern.containsMatchIn(result)) {
                    warnings.add(ConversionWarning(
                        WarningType.SYNTAX_DIFFERENCE,
                        "MySQL 8.0+에서만 함수 기반 인덱스가 지원됩니다.",
                        WarningSeverity.WARNING,
                        "MySQL 8.0 미만에서는 Generated Column을 사용하세요."
                    ))
                }
            }
            else -> {}
        }

        // NVL 함수를 COALESCE로 변환 (Oracle → PostgreSQL)
        if (sourceDialect == DialectType.ORACLE && targetDialect == DialectType.POSTGRESQL) {
            result = result.replace(Regex("\\bNVL\\s*\\(", RegexOption.IGNORE_CASE), "COALESCE(")
            if (sql != result) {
                appliedRules.add("인덱스 내 NVL → COALESCE 변환")
            }
        }

        // COALESCE를 NVL로 변환 (PostgreSQL → Oracle)
        if (sourceDialect == DialectType.POSTGRESQL && targetDialect == DialectType.ORACLE) {
            result = result.replace(Regex("\\bCOALESCE\\s*\\(", RegexOption.IGNORE_CASE), "NVL(")
            if (sql != result) {
                appliedRules.add("인덱스 내 COALESCE → NVL 변환")
            }
        }

        return result
    }

    /**
     * DROP TABLE 변환
     */
    fun convertDropTable(
        sql: String,
        sourceDialect: DialectType,
        targetDialect: DialectType,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        // CASCADE CONSTRAINTS (Oracle) → CASCADE (PostgreSQL)
        if (sourceDialect == DialectType.ORACLE) {
            if (targetDialect == DialectType.POSTGRESQL) {
                result = result.replace(
                    Regex("CASCADE\\s+CONSTRAINTS", RegexOption.IGNORE_CASE),
                    "CASCADE"
                )
                appliedRules.add("CASCADE CONSTRAINTS → CASCADE")
            }
        }

        // PURGE 제거 (Oracle 전용)
        if (targetDialect != DialectType.ORACLE) {
            result = result.replace(Regex("\\s+PURGE\\b", RegexOption.IGNORE_CASE), "")
        }

        appliedRules.add("DROP TABLE 변환")
        return result
    }

    private fun convertTableName(name: String, targetDialect: DialectType): String {
        val cleaned = name.trim('"', '`', '[', ']')
        return when (targetDialect) {
            DialectType.MYSQL -> "`$cleaned`"
            else -> "\"$cleaned\""
        }
    }

    private fun convertColumnName(name: String, targetDialect: DialectType): String {
        val cleaned = name.trim('"', '`', '[', ']')
        return when (targetDialect) {
            DialectType.MYSQL -> "`$cleaned`"
            else -> "\"$cleaned\""
        }
    }
}