package com.sqlswitcher.converter.dialect

import com.sqlswitcher.converter.core.*
import com.sqlswitcher.converter.feature.*
import org.springframework.stereotype.Component

/**
 * PostgreSQL SQL 방언 - 슬림화된 버전
 *
 * 핵심 로직은 서비스 클래스에 위임하고, PostgreSQL 특화 기능만 구현
 */
@Component
class PostgreSqlDialectNew(
    functionService: FunctionConversionService,
    dataTypeService: DataTypeConversionService,
    ddlService: DDLConversionService,
    selectService: SelectConversionService,
    triggerService: TriggerConversionService,
    sequenceService: SequenceConversionService
) : BaseDialect(
    functionService, dataTypeService, ddlService, selectService, triggerService, sequenceService
) {
    override val dialectType = DialectType.POSTGRESQL

    /**
     * PostgreSQL 특화 변환
     */
    override fun convertSql(
        sql: String,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>,
        options: ConversionOptions?
    ): String {
        var result = super.convertSql(sql, targetDialect, warnings, appliedRules, options)

        // PostgreSQL 특화: SERIAL 처리
        result = handleSerial(result, targetDialect, warnings, appliedRules)

        // PostgreSQL 특화: ARRAY 타입 처리
        result = handleArrayType(result, targetDialect, warnings, appliedRules)

        // PostgreSQL 특화: JSONB 연산자 처리
        result = handleJsonOperators(result, targetDialect, warnings, appliedRules)

        // PostgreSQL 특화: RETURNING 절 처리
        result = handleReturning(result, targetDialect, warnings, appliedRules)

        // PostgreSQL 특화: :: 캐스팅 처리
        result = handleCasting(result, targetDialect, warnings, appliedRules)

        // PostgreSQL 특화: ILIKE 처리
        result = handleILike(result, targetDialect, warnings, appliedRules)

        return result
    }

    /**
     * SERIAL 타입 처리
     */
    private fun handleSerial(
        sql: String,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        when (targetDialect) {
            DialectType.MYSQL -> {
                // SERIAL → INT AUTO_INCREMENT
                result = result.replace(Regex("\\bBIGSERIAL\\b", RegexOption.IGNORE_CASE), "BIGINT AUTO_INCREMENT")
                result = result.replace(Regex("\\bSERIAL\\b", RegexOption.IGNORE_CASE), "INT AUTO_INCREMENT")
                result = result.replace(Regex("\\bSMALLSERIAL\\b", RegexOption.IGNORE_CASE), "SMALLINT AUTO_INCREMENT")
                if (result != sql) {
                    appliedRules.add("SERIAL → AUTO_INCREMENT 변환")
                }
            }
            DialectType.ORACLE, DialectType.TIBERO -> {
                // SERIAL → NUMBER + GENERATED AS IDENTITY
                result = result.replace(Regex("\\bBIGSERIAL\\b", RegexOption.IGNORE_CASE), "NUMBER(19) GENERATED BY DEFAULT AS IDENTITY")
                result = result.replace(Regex("\\bSERIAL\\b", RegexOption.IGNORE_CASE), "NUMBER(10) GENERATED BY DEFAULT AS IDENTITY")
                result = result.replace(Regex("\\bSMALLSERIAL\\b", RegexOption.IGNORE_CASE), "NUMBER(5) GENERATED BY DEFAULT AS IDENTITY")
                if (result != sql) {
                    appliedRules.add("SERIAL → GENERATED AS IDENTITY 변환")
                }
            }
            else -> {}
        }

        return result
    }

    /**
     * ARRAY 타입 처리
     */
    private fun handleArrayType(
        sql: String,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        if (!sql.uppercase().contains("ARRAY") && !sql.contains("[]")) {
            return result
        }

        when (targetDialect) {
            DialectType.MYSQL -> {
                warnings.add(ConversionWarning(
                    type = WarningType.UNSUPPORTED_FUNCTION,
                    message = "MySQL은 ARRAY 타입을 지원하지 않습니다.",
                    severity = WarningSeverity.WARNING,
                    suggestion = "JSON 타입이나 별도 테이블로 대체하세요."
                ))
                // TYPE[] → JSON
                result = result.replace(Regex("""(\w+)\s*\[\s*\]"""), "JSON")
                result = result.replace(Regex("\\bARRAY\\s*\\[", RegexOption.IGNORE_CASE), "JSON_ARRAY(")
                appliedRules.add("ARRAY → JSON 변환")
            }
            DialectType.ORACLE, DialectType.TIBERO -> {
                warnings.add(ConversionWarning(
                    type = WarningType.UNSUPPORTED_FUNCTION,
                    message = "Oracle은 PostgreSQL ARRAY를 직접 지원하지 않습니다.",
                    severity = WarningSeverity.WARNING,
                    suggestion = "VARRAY, Nested Table 또는 JSON을 사용하세요."
                ))
                result = result.replace(Regex("""(\w+)\s*\[\s*\]"""), "CLOB")
                appliedRules.add("ARRAY → CLOB 변환")
            }
            else -> {}
        }

        return result
    }

    /**
     * JSON/JSONB 연산자 처리
     */
    private fun handleJsonOperators(
        sql: String,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        when (targetDialect) {
            DialectType.MYSQL -> {
                // -> 연산자 → JSON_EXTRACT
                result = result.replace(Regex("""(\w+)\s*->\s*'([^']+)'""")) { match ->
                    appliedRules.add("-> → JSON_EXTRACT 변환")
                    "JSON_EXTRACT(${match.groupValues[1]}, '\$.${match.groupValues[2]}')"
                }
                // ->> 연산자 → JSON_UNQUOTE(JSON_EXTRACT(...))
                result = result.replace(Regex("""(\w+)\s*->>\s*'([^']+)'""")) { match ->
                    appliedRules.add("->> → JSON_UNQUOTE(JSON_EXTRACT()) 변환")
                    "JSON_UNQUOTE(JSON_EXTRACT(${match.groupValues[1]}, '\$.${match.groupValues[2]}'))"
                }
                // JSONB → JSON
                result = result.replace(Regex("\\bJSONB\\b", RegexOption.IGNORE_CASE), "JSON")
            }
            DialectType.ORACLE, DialectType.TIBERO -> {
                // ->> 연산자 → JSON_VALUE
                result = result.replace(Regex("""(\w+)\s*->>\s*'([^']+)'""")) { match ->
                    appliedRules.add("->> → JSON_VALUE 변환")
                    "JSON_VALUE(${match.groupValues[1]}, '\$.${match.groupValues[2]}')"
                }
                // -> 연산자 → JSON_QUERY
                result = result.replace(Regex("""(\w+)\s*->\s*'([^']+)'""")) { match ->
                    appliedRules.add("-> → JSON_QUERY 변환")
                    "JSON_QUERY(${match.groupValues[1]}, '\$.${match.groupValues[2]}')"
                }
                // JSONB → CLOB (Oracle 12c 이전)
                result = result.replace(Regex("\\bJSONB\\b", RegexOption.IGNORE_CASE), "CLOB")
            }
            else -> {}
        }

        return result
    }

    /**
     * RETURNING 절 처리
     */
    private fun handleReturning(
        sql: String,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        if (!sql.uppercase().contains("RETURNING")) {
            return result
        }

        when (targetDialect) {
            DialectType.MYSQL -> {
                warnings.add(ConversionWarning(
                    type = WarningType.UNSUPPORTED_FUNCTION,
                    message = "MySQL은 RETURNING 절을 지원하지 않습니다.",
                    severity = WarningSeverity.WARNING,
                    suggestion = "INSERT 후 LAST_INSERT_ID()를 사용하거나 별도 SELECT를 실행하세요."
                ))
                // RETURNING 절 제거
                result = result.replace(Regex("""\s+RETURNING\s+.+$""", RegexOption.IGNORE_CASE), "")
                appliedRules.add("RETURNING 절 제거 (MySQL 미지원)")
            }
            DialectType.ORACLE, DialectType.TIBERO -> {
                // Oracle은 RETURNING INTO 지원
                if (!result.uppercase().contains("RETURNING INTO")) {
                    warnings.add(ConversionWarning(
                        type = WarningType.SYNTAX_DIFFERENCE,
                        message = "Oracle에서는 RETURNING INTO 구문을 사용합니다.",
                        severity = WarningSeverity.INFO,
                        suggestion = "RETURNING column INTO variable 형식으로 변경하세요."
                    ))
                }
            }
            else -> {}
        }

        return result
    }

    /**
     * :: 캐스팅 처리
     */
    private fun handleCasting(
        sql: String,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        if (!sql.contains("::")) {
            return result
        }

        when (targetDialect) {
            DialectType.MYSQL -> {
                // ::type → CAST(... AS type)
                result = result.replace(Regex("""(\w+)::(\w+)""")) { match ->
                    val expr = match.groupValues[1]
                    val type = convertTypeForMySql(match.groupValues[2])
                    appliedRules.add(":: → CAST() 변환")
                    "CAST($expr AS $type)"
                }
            }
            DialectType.ORACLE, DialectType.TIBERO -> {
                // ::type → CAST(... AS type) 또는 TO_* 함수
                result = result.replace(Regex("""(\w+)::(\w+)""")) { match ->
                    val expr = match.groupValues[1]
                    val type = convertTypeForOracle(match.groupValues[2])
                    appliedRules.add(":: → CAST() 변환")
                    "CAST($expr AS $type)"
                }
            }
            else -> {}
        }

        return result
    }

    /**
     * ILIKE 처리
     */
    private fun handleILike(
        sql: String,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        if (!sql.uppercase().contains("ILIKE")) {
            return result
        }

        when (targetDialect) {
            DialectType.MYSQL -> {
                // ILIKE → LIKE (MySQL LIKE는 기본적으로 대소문자 구분 안함)
                result = result.replace(Regex("\\bILIKE\\b", RegexOption.IGNORE_CASE), "LIKE")
                appliedRules.add("ILIKE → LIKE 변환 (MySQL)")
            }
            DialectType.ORACLE, DialectType.TIBERO -> {
                // ILIKE → UPPER(...) LIKE UPPER(...)
                result = result.replace(
                    Regex("""(\w+)\s+ILIKE\s+'([^']+)'""", RegexOption.IGNORE_CASE)
                ) { match ->
                    appliedRules.add("ILIKE → UPPER() LIKE UPPER() 변환")
                    "UPPER(${match.groupValues[1]}) LIKE UPPER('${match.groupValues[2]}')"
                }
            }
            else -> {}
        }

        return result
    }

    private fun convertTypeForMySql(pgType: String): String {
        return when (pgType.uppercase()) {
            "TEXT" -> "CHAR"
            "INTEGER", "INT4" -> "SIGNED"
            "BIGINT", "INT8" -> "SIGNED"
            "SMALLINT", "INT2" -> "SIGNED"
            "REAL", "FLOAT4" -> "DECIMAL"
            "DOUBLE PRECISION", "FLOAT8" -> "DECIMAL"
            "BOOLEAN", "BOOL" -> "UNSIGNED"
            "TIMESTAMP", "TIMESTAMPTZ" -> "DATETIME"
            "DATE" -> "DATE"
            "TIME" -> "TIME"
            else -> pgType
        }
    }

    private fun convertTypeForOracle(pgType: String): String {
        return when (pgType.uppercase()) {
            "TEXT" -> "VARCHAR2(4000)"
            "INTEGER", "INT4" -> "NUMBER(10)"
            "BIGINT", "INT8" -> "NUMBER(19)"
            "SMALLINT", "INT2" -> "NUMBER(5)"
            "REAL", "FLOAT4" -> "BINARY_FLOAT"
            "DOUBLE PRECISION", "FLOAT8" -> "BINARY_DOUBLE"
            "BOOLEAN", "BOOL" -> "NUMBER(1)"
            "TIMESTAMP", "TIMESTAMPTZ" -> "TIMESTAMP"
            "DATE" -> "DATE"
            "TIME" -> "VARCHAR2(15)"
            else -> pgType
        }
    }
}