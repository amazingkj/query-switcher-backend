package com.sqlswitcher.converter.dialect

import com.sqlswitcher.converter.DialectType
import com.sqlswitcher.converter.ConversionWarning
import com.sqlswitcher.converter.WarningType
import com.sqlswitcher.converter.WarningSeverity
import com.sqlswitcher.converter.feature.FunctionConversionService
import com.sqlswitcher.converter.feature.DataTypeConversionService
import com.sqlswitcher.converter.feature.DDLConversionService
import com.sqlswitcher.converter.feature.SelectConversionService
import com.sqlswitcher.converter.feature.procedure.TriggerConversionService
import com.sqlswitcher.converter.feature.SequenceConversionService
import com.sqlswitcher.converter.feature.PartitionConversionService
import com.sqlswitcher.converter.feature.ViewConversionService
import com.sqlswitcher.converter.feature.MergeConversionService
import com.sqlswitcher.converter.feature.ProcedureConversionService
import org.springframework.stereotype.Component

/**
 * PostgreSQL SQL 방언 - 슬림화된 버전
 *
 * 파티션 변환은 BaseDialect의 PartitionConversionService에서 처리
 * PostgreSQL 특화 기능(SERIAL, ::캐스팅, ILIKE, RETURNING)만 구현
 */
@Component("postgreSqlDialectNew")
class PostgreSqlDialectNew(
    functionService: FunctionConversionService,
    dataTypeService: DataTypeConversionService,
    ddlService: DDLConversionService,
    selectService: SelectConversionService,
    triggerService: TriggerConversionService,
    sequenceService: SequenceConversionService,
    partitionService: PartitionConversionService,
    viewService: ViewConversionService,
    mergeService: MergeConversionService,
    procedureService: ProcedureConversionService
) : BaseDialect(
    functionService, dataTypeService, ddlService, selectService, triggerService, sequenceService, partitionService, viewService, mergeService, procedureService
) {
    override fun getDialectType() = DialectType.POSTGRESQL

    override fun convertSql(
        sql: String,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        var result = super.convertSql(sql, targetDialect, warnings, appliedRules)

        // PostgreSQL 특화: SERIAL 처리
        result = handleSerial(result, targetDialect, appliedRules)

        // PostgreSQL 특화: :: 캐스팅 처리
        result = handleCasting(result, targetDialect, appliedRules)

        // PostgreSQL 특화: ILIKE 처리
        result = handleILike(result, targetDialect, appliedRules)

        // PostgreSQL 특화: RETURNING 처리
        result = handleReturning(result, targetDialect, warnings, appliedRules)

        return result
    }

    private fun handleSerial(
        sql: String,
        targetDialect: DialectType,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        when (targetDialect) {
            DialectType.MYSQL -> {
                result = result.replace(Regex("\\bBIGSERIAL\\b", RegexOption.IGNORE_CASE), "BIGINT AUTO_INCREMENT")
                result = result.replace(Regex("\\bSERIAL\\b", RegexOption.IGNORE_CASE), "INT AUTO_INCREMENT")
                if (result != sql) appliedRules.add("SERIAL → AUTO_INCREMENT 변환")
            }
            DialectType.ORACLE -> {
                result = result.replace(Regex("\\bBIGSERIAL\\b", RegexOption.IGNORE_CASE), "NUMBER(19) GENERATED BY DEFAULT AS IDENTITY")
                result = result.replace(Regex("\\bSERIAL\\b", RegexOption.IGNORE_CASE), "NUMBER(10) GENERATED BY DEFAULT AS IDENTITY")
                if (result != sql) appliedRules.add("SERIAL → GENERATED AS IDENTITY 변환")
            }
            else -> {}
        }

        return result
    }

    private fun handleCasting(
        sql: String,
        targetDialect: DialectType,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        if (!sql.contains("::")) return result

        when (targetDialect) {
            DialectType.MYSQL, DialectType.ORACLE -> {
                result = result.replace(Regex("""(\w+)::(\w+)""")) { match ->
                    val expr = match.groupValues[1]
                    val type = match.groupValues[2]
                    appliedRules.add(":: → CAST() 변환")
                    "CAST($expr AS $type)"
                }
            }
            else -> {}
        }

        return result
    }

    private fun handleILike(
        sql: String,
        targetDialect: DialectType,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        if (!sql.uppercase().contains("ILIKE")) return result

        when (targetDialect) {
            DialectType.MYSQL -> {
                result = result.replace(Regex("\\bILIKE\\b", RegexOption.IGNORE_CASE), "LIKE")
                appliedRules.add("ILIKE → LIKE 변환")
            }
            DialectType.ORACLE -> {
                result = result.replace(
                    Regex("""(\w+)\s+ILIKE\s+'([^']+)'""", RegexOption.IGNORE_CASE)
                ) { match ->
                    appliedRules.add("ILIKE → UPPER() LIKE UPPER() 변환")
                    "UPPER(${match.groupValues[1]}) LIKE UPPER('${match.groupValues[2]}')"
                }
            }
            else -> {}
        }

        return result
    }

    private fun handleReturning(
        sql: String,
        targetDialect: DialectType,
        warnings: MutableList<ConversionWarning>,
        appliedRules: MutableList<String>
    ): String {
        var result = sql

        if (!sql.uppercase().contains("RETURNING")) return result

        when (targetDialect) {
            DialectType.MYSQL -> {
                warnings.add(ConversionWarning(
                    type = WarningType.UNSUPPORTED_FUNCTION,
                    message = "MySQL은 RETURNING 절을 지원하지 않습니다.",
                    severity = WarningSeverity.WARNING,
                    suggestion = "INSERT 후 LAST_INSERT_ID()를 사용하세요."
                ))
                result = result.replace(Regex("""\s+RETURNING\s+.+$""", RegexOption.IGNORE_CASE), "")
                appliedRules.add("RETURNING 절 제거")
            }
            else -> {}
        }

        return result
    }
}